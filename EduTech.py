# -*- coding: utf-8 -*-
"""copy of proyek 1 fix.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NwqfxAHfPQJCVlRunvJgUAg9kVGAmIgQ

# Proyek Akhir: Menyelesaikan Permasalahan Perusahaan Edutech

- Nama:ERIKA BUDIARTI
- Email:erika.analytic@gmail.com
- Id Dicoding:erika_budiarti

## Persiapan

### Menyiapkan library yang dibutuhkan
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix, classification_report

import joblib

"""### Menyiapkan data yang akan digunakan"""

employee_df = pd.read_csv("/content/employee_data.csv", encoding='windows-1252')

"""## Data Understanding"""

employee_df.head(5)

employee_df.shape

employee_df.dtypes

employee_df.describe(include='object')

employee_df.describe()

employee_df.duplicated().sum()

employee_df.isna().sum()

"""## Data Preparation / Preprocessing

### Handling Missing Value
"""

mode_value = employee_df['Attrition'].mode()[0]
employee_df['Attrition'].fillna(mode_value, inplace=True)

employee_df.isna().sum()

"""### Feature Engineering"""

employee_df['PerformanceSatisfactionIndex'] = employee_df[['EnvironmentSatisfaction', 'JobSatisfaction', 'RelationshipSatisfaction']].mean(axis=1)
employee_df.drop(['EnvironmentSatisfaction', 'JobSatisfaction', 'RelationshipSatisfaction'],axis=1,inplace=True)

def satisfaction(score):
    score = float(score)
    if (score >= 1.00) and (score <= 1.99):
        return 'Low'
    elif (score >= 2.0) and (score <= 2.99):
        return 'Medium'
    elif (score >= 3.00) and (score <= 3.99):
        return 'High'
    else:
        return 'Very High'

employee_df['PerformanceSatisfactionIndex'] = employee_df['PerformanceSatisfactionIndex'].apply(satisfaction)

employee_df['ExperiencePriorToCurrentJob'] = employee_df['TotalWorkingYears'] - employee_df['YearsAtCompany']
employee_df.drop(['TotalWorkingYears', 'YearsAtCompany'],axis=1,inplace=True)

def experience(years):
    if (years >= 0) and (years <= 5):
        return 'Junior'
    elif (years >= 6) and (years <= 10):
        return 'Mid-level'
    elif (years >= 11) and (years <= 20):
        return 'Senior'
    elif (years >= 21) and (years <= 30):
        return 'Expert'
    else:
        return 'Veteran'

employee_df['ExperiencePriorToCurrentJob'] = employee_df['ExperiencePriorToCurrentJob'].apply(experience)

employee_df['EmployeeEngagementScore'] = (employee_df['JobInvolvement'] + employee_df['PerformanceRating'] + employee_df['WorkLifeBalance']) / 3
employee_df.drop(['JobInvolvement', 'PerformanceRating', 'WorkLifeBalance'],axis=1,inplace=True)

def engagement(score):
    score = float(score)
    if (score >= 1.00) and (score <= 1.99):
        return 'Bad'
    elif (score >= 2.0) and (score <= 2.99):
        return 'Good'
    elif (score >= 3.00) and (score <= 3.99):
        return 'Better'
    else:
        return 'Best'

employee_df['EmployeeEngagementScore'] = employee_df['EmployeeEngagementScore'].apply(engagement)

def distance_category(distance):
    if (distance >= 1) & (distance <= 10):
        return 'Short Distance'
    elif (distance >= 11) & (distance <= 20):
        return 'Medium Distance'
    else:
        return 'Long Distance'

employee_df['DistanceFromHomeCategory'] = employee_df['DistanceFromHome'].apply(distance_category)
employee_df.drop(['DistanceFromHome'],axis=1,inplace=True)

def generation(age):
    if (age >= 61) & (age <= 70):
        return 'Baby Boomers'
    elif (age >= 51) & (age <= 60):
        return 'Gen X'
    elif (age >= 41) & (age <= 50):
        return 'Gen Y'
    elif (age >= 31 ) & (age <= 40):
        return 'Millennials'
    else:
        return 'Gen Z'

employee_df['AgeGeneration'] = employee_df['Age'].apply(generation)
employee_df.drop(['Age'],axis=1,inplace=True)

# Mapping
education_map = {
    1: 'Below College',
    2: 'College',
    3: 'Bachelor',
    4: 'Master',
    5: 'Doctor'
}
employee_df['Education'] = employee_df['Education'].map(education_map)

job_level_mapping = {
    1: 'Staff',
    2: 'Junior Supervisor',
    3: 'Senior Supervisor',
    4: 'Junior Manager',
    5: 'Senior Manager'
}
employee_df['JobLevel'] = employee_df['JobLevel'].map(job_level_mapping)

employee_df.drop(['StandardHours','EmployeeCount', 'Over18'],axis=1,inplace=True)

employee_df = employee_df.reindex(sorted(employee_df.columns), axis=1)
employee_df.dtypes

employee_df.head()

"""### Exploratory Data Analysis"""

employee_df['Attrition'] = employee_df['Attrition'].factorize(['No','Yes'])[0]
employee_df['Attrition'].value_counts()

attrition = employee_df[employee_df['Attrition'] == 1]
no_attrition = employee_df[employee_df['Attrition'] == 0]

attrition_count = len(attrition)
no_attrition_count = len(no_attrition)

categories = ['Yes_attrition', 'No_attrition']
counts = [attrition_count, no_attrition_count]

plt.figure(figsize=(8, 5))
sns.barplot(x=counts, y=categories, hue=categories, palette=['pink', 'lightblue'], dodge=False, legend=False)

plt.title('Count of attrition variable')
plt.show()

plt.figure(figsize=(8, 8))

attrition_counts = employee_df['Attrition'].value_counts()
labels = attrition_counts.index
sizes = attrition_counts.values
colors = ['lightblue', 'pink']

plt.pie(sizes, colors=colors, autopct='%1.1f%%', startangle=140, labeldistance=0.7)
plt.axis('equal')
plt.legend(labels, loc="best")

plt.title('Distribution of attrition variable')
plt.show()

# Define color palette
colors = ['lightblue', 'pink']

# Create subplots
fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(15, 15))

# Plot Attrition by Age Generation
sns.countplot(x='AgeGeneration', hue='Attrition', data=employee_df, palette=colors, ax=axes[0, 0])
axes[0, 0].set_title('Attrition by Age Generation')
axes[0, 0].set_xlabel('Age Generation')
axes[0, 0].set_ylabel('Count')
axes[0, 0].legend(title='Attrition', loc='upper right', labels=['No', 'Yes'])
for p in axes[0, 0].patches:
    if p.get_height() > 0:
        axes[0, 0].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Gender
sns.countplot(x='Gender', hue='Attrition', data=employee_df, palette=colors, ax=axes[0, 1])
axes[0, 1].set_title('Attrition by Gender')
axes[0, 1].set_xlabel('Gender')
axes[0, 1].set_ylabel('Count')
axes[0, 1].legend(title='Attrition', loc='upper right', labels=['No', 'Yes'])
for p in axes[0, 1].patches:
    if p.get_height() > 0:
        axes[0, 1].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Business Travel
sns.countplot(x='BusinessTravel', hue='Attrition', data=employee_df, palette=colors, ax=axes[1, 0])
axes[1, 0].set_title('Attrition by Business Travel')
axes[1, 0].set_xlabel('Business Travel')
axes[1, 0].set_ylabel('Count')
axes[1, 0].legend(title='Attrition', loc='upper right', labels=['No', 'Yes'])
for p in axes[1, 0].patches:
    if p.get_height() > 0:
        axes[1, 0].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Distance From Home
sns.countplot(x='DistanceFromHomeCategory', hue='Attrition', data=employee_df, palette=colors, ax=axes[1, 1])
axes[1, 1].set_title('Attrition by Distance From Home')
axes[1, 1].set_xlabel('Distance From Home')
axes[1, 1].set_ylabel('Count')
axes[1, 1].legend(title='Attrition', loc='upper right', labels=['No', 'Yes'])
for p in axes[1, 1].patches:
    if p.get_height() > 0:
        axes[1, 1].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Education
sns.countplot(x='Education', hue='Attrition', data=employee_df, palette=colors, ax=axes[2, 0])
axes[2, 0].set_title('Attrition by Education')
axes[2, 0].set_xlabel('Education Stage')
axes[2, 0].set_ylabel('Count')
axes[2, 0].legend(title='Attrition', loc='upper right', labels=['No', 'Yes'])
for p in axes[2, 0].patches:
    if p.get_height() > 0:
        axes[2, 0].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Department
sns.countplot(x='Department', hue='Attrition', data=employee_df, palette=colors, ax=axes[2, 1])
axes[2, 1].set_title('Attrition by Department')
axes[2, 1].set_xlabel('Department')
axes[2, 1].set_ylabel('Count')
axes[2, 1].legend(title='Attrition', loc='upper right', labels=['No', 'Yes'])
for p in axes[2, 1].patches:
    if p.get_height() > 0:
        axes[2, 1].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Adjust layout
plt.tight_layout()
plt.show()

# Define color palette
colors = ['lightblue', 'pink']

# Create subplots
fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(15, 15))

# Plot Attrition by Job Level
sns.countplot(x='JobLevel', hue='Attrition', data=employee_df, palette=colors, ax=axes[0, 0])
axes[0, 0].set_title('Attrition by Job Level')
axes[0, 0].set_xlabel('Job Level')
axes[0, 0].set_ylabel('Count')
for p in axes[0, 0].patches:
    if p.get_height() > 0:
        axes[0, 0].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Employee Engagement Score
sns.countplot(x='EmployeeEngagementScore', hue='Attrition', data=employee_df, palette=colors, ax=axes[0, 1])
axes[0, 1].set_title('Attrition by Employee Engagement Score')
axes[0, 1].set_xlabel('Employee Engagement')
axes[0, 1].set_ylabel('Count')
for p in axes[0, 1].patches:
    if p.get_height() > 0:
        axes[0, 1].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Employee Performance Satisfaction Index
sns.countplot(x='PerformanceSatisfactionIndex', hue='Attrition', data=employee_df, palette=colors, ax=axes[1, 0])
axes[1, 0].set_title('Attrition by Employee Performance Satisfaction Index')
axes[1, 0].set_xlabel('Employee Satisfaction')
axes[1, 0].set_ylabel('Count')
for p in axes[1, 0].patches:
    if p.get_height() > 0:
        axes[1, 0].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Employee Prior Experience
sns.countplot(x='ExperiencePriorToCurrentJob', hue='Attrition', data=employee_df, palette=colors, ax=axes[1, 1])
axes[1, 1].set_title('Attrition by Employee Prior Experience')
axes[1, 1].set_xlabel('Employee Prior Experience')
axes[1, 1].set_ylabel('Count')
for p in axes[1, 1].patches:
    if p.get_height() > 0:
        axes[1, 1].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Percent Salary Hike
sns.countplot(x='PercentSalaryHike', hue='Attrition', data=employee_df, palette=colors, ax=axes[2, 0])
axes[2, 0].set_title('Attrition by Increase of Salary (Percentage)')
axes[2, 0].set_xlabel('Increase of Salary (Percentage)')
axes[2, 0].set_ylabel('Count')
for p in axes[2, 0].patches:
    if p.get_height() > 0:
        axes[2, 0].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')

# Plot Attrition by Years Since Last Promotion
sns.countplot(x='YearsSinceLastPromotion', hue='Attrition', data=employee_df, palette=colors, ax=axes[2, 1])
axes[2, 1].set_title('Attrition by Last Promotion (Years)')
axes[2, 1].set_xlabel('Last Promotion (Years)')
axes[2, 1].set_ylabel('Count')
for p in axes[2, 1].patches:
    if p.get_height() > 0:
        axes[2, 1].annotate(str(int(p.get_height())), (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', xytext=(0, 8), textcoords='offset points')


# Adjust layout
plt.tight_layout()
plt.show()

"""## Modeling"""

# Filter Categorical Features
category_cols = employee_df.select_dtypes(exclude=['int32','int64','float32','float64'])
category_cols.head()

category_cols.nunique()

label_encoder=LabelEncoder()
columns_to_encode = ['Attrition', 'OverTime', 'AgeGeneration', 'BusinessTravel', 'Department', 'DistanceFromHomeCategory',
                     'Education', 'EducationField', 'EmployeeEngagementScore', 'MaritalStatus', 'ExperiencePriorToCurrentJob',
                     'JobLevel', 'JobRole', 'Gender', 'PerformanceSatisfactionIndex']

for column in columns_to_encode:
    employee_df[column] = label_encoder.fit_transform(employee_df[column])

emp_df = employee_df.drop(['YearsInCurrentRole' , 'YearsSinceLastPromotion', 'YearsWithCurrManager'],axis=1)
emp_df.head()

X=np.array(emp_df.drop(['Attrition'],axis=1))
y=np.array(emp_df['Attrition'])

X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42, test_size=0.2)
print(X_train.shape)
print(X_test.shape)

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

"""### Model Logistic Regression

"""

# Initialize the Logistic Regression classifier
clf_lr = LogisticRegression()

# Define the grid of hyperparameters
param_grid1 = {
    'C' :[0.1, 1, 10, 100],
    'max_iter': [100, 150, 200, 300],
    'multi_class': ['auto'],
    'solver': ['lbfgs', 'liblinear', 'newton-cg', 'sag', 'saga']
}

# Initialize GridSearchCV
gs1 = GridSearchCV(
    estimator=clf_lr,
    param_grid=param_grid1,
    cv=5,
    n_jobs=-1,
    scoring='accuracy'
)

# Train the classifier using GridSearchCV
clf_lr_grid = gs1.fit(X_train, y_train)

# Make predictions on the test set
y_pred = clf_lr_grid.predict(X_test)

# Print the best parameters found by GridSearchCV
print("Best parameters:", clf_lr_grid.best_params_)

# Calculate and print the test accuracy
test_accuracy = accuracy_score(y_test, y_pred)
print("The test accuracy score of Logistic Regression is", test_accuracy)

"""## Evaluation"""

lr_cm = confusion_matrix(y_test, y_pred)
print("Confusion Matrix of Logistric Regression:")
print(lr_cm)

plt.figure(figsize=(6, 4))
sns.heatmap(lr_cm, annot=True, cmap='Spectral', fmt='g',
            xticklabels=['Positive', 'Negative'],
            yticklabels=['Positive', 'Negative'])
plt.xlabel('Predicted labels')
plt.ylabel('Actual labels')
plt.title('Confusion Matrix of Logistic Regression')
plt.show()

print("The Classification Report of Logistic Regression")
print(classification_report(y_test, y_pred))

"""## Deployment"""

# Save the model with joblib
joblib.dump(clf_lr_grid, 'logistic_regression_model.pkl')